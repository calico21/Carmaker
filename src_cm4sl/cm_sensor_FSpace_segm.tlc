%%
%%  Copyright Â©1998-2025 IPG Automotive GmbH. All rights reserved.
%%  www.ipg-automotive.com
%%
%implements "cm_sensor_FSpace_segm" "C"

%include "cm_rtwlib.tlc"


%function BlockTypeSetup(block, system) void
    %<LibAddToCommonIncludes("<Global.h>")>
    %if CM_IsRtiTarget || CM_IsDsRtTarget
	%<LibAddToCommonIncludes("<CM_Sfun_Utils.h>")>
    %endif
    %<LibAddToCommonIncludes("<SimCore.h>")>
    %<LibAddToCommonIncludes("<Log.h>")>
    %<LibAddToCommonIncludes("<Vehicle/Sensor_FSpace.h>")>
%endfunction


%function Start (block, system) Output
    %if CM_IsCarMakerTarget
	%assign sisfirststep = LibBlockIWork(SIsFirstStep, "", "", 0)

	%<sisfirststep> = 1;
    %else
	%assign _sname = block.SFcnParamSettings[0]._SName
	%assign sname  = block.SFcnParamSettings[0].SName
	%assign shasextindex = CAST("Boolean", block.SFcnParamSettings[0].SHasExtIndex)

	%if !%<shasextindex>
	    %assign shandle = LibBlockIWork(SHandle, "", "", 0)
	    %<shandle> = MdlItems_Add(MdlItem_FSpaceSensor, "%<sname>", MdlIdx_Default); // %<_sname>
	%endif

	%assign serrorraised = LibBlockIWork(SErrorRaised, "", "", 0)
	%<serrorraised> = 0;
    %endif
%endfunction


%function Outputs (block, system) Output
    {
	%assign shasextindex = block.SFcnParamSettings[0].SHasExtIndex != 0
	%assign plusactive   = block.SFcnParamSettings[0].PlusActive != 0
	%assign spath        = block.SFcnParamSettings[0].SPath
	static const char spath[] = "%<spath>";
	const tFSpaceSensor *fs;
	const tSegment *seg;
	int seg_idx;

	%if CM_IsCarMakerTarget
	    static tFSpaceSensor ZeroSensor = { { { 0 } } };
	    static tSegment ZeroFSpaceSegment = { 0 };

	    %if %<shasextindex>
		int fs_idx = %<LibBlockInputSignal(0, "", "", 0)>;
		if (SimCore.State != SCState_Simulate ||
		    (fs = FSpaceSensor_GetByIndex(fs_idx)) == NULL) {
		    fs = &ZeroSensor;
		}
	    %else
		%assign _sname          = block.SFcnParamSettings[0]._SName
		%assign sname           = block.SFcnParamSettings[0].SName
		%assign salphaindex     = CAST("Number", block.SFcnParamSettings[0].SAlphaIndex)
		%assign sindex          = LibBlockIWork(SIndex, "", "", 0)
		%assign sisfirststep    = LibBlockIWork(SIsFirstStep, "", "", 0)
		%assign ssensor         = LibBlockPWork(SSensor, "", "", 0)

		if (%<sisfirststep>) {
		    %if %<salphaindex> >= 0
			%<sindex> = %<salphaindex>;
		    %else
			%<sindex> = FSpaceSensor_FindIndexForName("%<sname>"); // %<_sname>
		    %endif
		    %<ssensor> = FSpaceSensor_GetByIndex(%<sindex>);
		    if (%<ssensor> == NULL) {
			%<ssensor> = &ZeroSensor;
			%<sindex> = -1;
		    }
		    if (%<sindex> >= 0 && %<plusactive> != ((const tFSpaceSensor *)%<ssensor>)->Plus.Active) {
			LogErrF(EC_General, "Free Space Sensor Segment configuration mismatch between block and sensor %i.\n"
					    "Please check the 'Plus' parameter of block '%s'.", %<sindex>, spath);
		    }
		    %<sisfirststep> = 0;
		}
		fs = (const tFSpaceSensor *)%<ssensor>;
	    %endif
	%else
	    int fs_idx;
	    %if %<shasextindex>
		fs_idx = %<LibBlockInputSignal(0, "", "", 0)>;
		if (SimCore.State != SCState_Simulate ||
		    (fs = FSpaceSensor_GetByIndex(fs_idx)) == NULL) {
		    fs = MdlZero.FSpaceSensor;
		    fs_idx = -1;
		}
	    %else
		%assign shandle = LibBlockIWork(SHandle, "", "", 0)
		const struct tMdlItemRef *ms = &MdlItems.Entries[%<shandle>].s[MdlItemIndex];
		fs = ms->Item;
		fs_idx = ms->Index;
	    %endif

	    %assign serrorraised = LibBlockIWork(SErrorRaised, "", "", 0)
	    if (!%<serrorraised> && fs_idx >= 0 && %<plusactive> != fs->Plus.Active) {
		%<serrorraised> = 1;
		LogErrF(EC_General, "Free Space Sensor Segment configuration mismatch between block and sensor %i.\n"
				    "Please check the 'Plus' parameter of block '%s'.", fs_idx, spath);
	    }
	%endif

	seg_idx = %<LibBlockInputSignal(1, "", "", 0)>;
	if (0 <= seg_idx && seg_idx < fs->nTotSegm) {
		seg = &fs->Segm[seg_idx];
	} else {
	    %if CM_IsCarMakerTarget
		seg = &ZeroFSpaceSegment;
	    %else
		seg = MdlZero.FSpaceSegment;
	    %endif
	    seg_idx = -1;
	}

	%assign sig0 = LibBlockOutputSignal(0, "", "", 0)
	%assign sig1 = LibBlockOutputSignal(1, "", "", 0)
	// Port 0: Segment index
	%<sig0> = seg_idx;

        // Port 1: Segment data
        %if plusactive == 1
	    %<sig1>.alpha    = seg->alpha_p;
	    %<sig1>.ds       = seg->ds_p;
	    %<sig1>.dv       = seg->dv_p;
	    %<sig1>.theta    = seg->theta_p;
	    %<sig1>.ObjId    = seg->ObjId;
	    %<sig1>.MatId    = seg->MatId;
	    %<sig1>.CosIncid = seg->cosincid;
        %else 
            %<sig1>.alpha = seg->alpha_p;
	    %<sig1>.ds    = seg->ds_p;
	    %<sig1>.theta = seg->theta_p;
	    %<sig1>.ObjId = seg->ObjId;
            %<sig1>.dv    = seg->dv_p;
	    %<sig1>.dv_x  = seg->dv[0];
	    %<sig1>.dv_y  = seg->dv[1];
	    %<sig1>.dv_z  = seg->dv[2];
	    %<sig1>.ds_x  = seg->ds[0];
	    %<sig1>.ds_y  = seg->ds[1];
	    %<sig1>.ds_z  = seg->ds[2];
        %endif
    }
%endfunction
